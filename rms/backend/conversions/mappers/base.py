from typing import List, Tuple, Dict

import pandas as pd

from rms.backend.conversions.data import VALUES_CONVERSIONS
from rms.backend.conversions.regexes import REGEXES
from rms.backend.conversions.types import ColumnType
from rms.backend.conversions.utils import extract_proposals, process_fuzzywuzzy
from rms.backend.spreadsheet import Column


class MapperMixin:
    """The most naive mapper mixin, interface for trivial mappers converting
    one spreadsheet column into one RMS column."""

    def __init__(self, target_column: str):
        self.target_column = target_column

    def __call__(self, column: Column, mapping: Dict = None) -> Column:
        """Converts the column."""
        return self.convert_column(column, mapping)

    def _convert_value(self, value):
        raise NotImplementedError

    def convert_column(self, column: Column, mapping: Dict = None) -> Column:
        """Converts column values according to proposals dict, which
        is either passed as mapping param or generated by the method.

        :param column: Column to be mapped
        :param mapping: Optional, dict encoding the mappings of the column values

        :returns: A Column object with converted values"""

        if mapping is not None:
            converted_vals = column.values.map(mapping, na_action='ignore')
        else:
            converted_vals = column.values.map(self.generate_proposals(column))
        return Column(self.target_column, converted_vals)

    def generate_proposals(self, column: Column) -> List[Tuple]:
        """Generates a list [(value, proposal)] for all unique
        values in the column. """

        unique_values = column.get_unique_values()
        return [(v, self._convert_value(v)) for v in unique_values]


class MultiColumnMapperMixin:
    """Many-to-many column mapper."""

    def __init__(self, target_columns: Tuple):
        self.target_columns = target_columns

    def __call__(self, *columns, mapping: Dict = None) -> Tuple[Column]:
        """Takes as input a sequence of Column objects, no need to pass a tuple."""
        return self.convert_columns(*columns, mapping=mapping)

    def _convert_values(self, values) -> pd.Series:
        """A function which takes a tuple and returns a pd.Series of values.
        Important to wrap pd.Series around the result as this is the way
        to make it composable with df.apply().

        IMPORTANT: Column names of the returned pd.Series must be the same as self.target_columns.
        """
        raise NotImplementedError

    def convert_columns(self, *columns, mapping: Dict = None) -> Tuple[Column]:
        # Make sure column lengths are the same, can be done faster with x.count(x[0]) == len(x) if necessary,
        # list.count() has a highly optimized C implementation
        assert len(set([len(c) for c in columns])) == 1

        df = pd.DataFrame({c.name: c.values for c in columns})
        mapped_df = df.apply(self._convert_values, axis=1)
        columns = [Column(column_name=col, column_values=mapped_df[col]) for col in self.target_columns]
        return tuple(columns)

    def generate_proposals(self, *columns) -> List[Tuple]:
        proposals = []
        for i in range(len(columns[0])):
            vals = tuple(c.values.iloc[i] for c in columns)
            proposals.append((vals, self._convert_values(vals)))
        return proposals


class BaseRMSMapper(MapperMixin):
    def __init__(self, target_column: str = '', target_type: ColumnType = None, regexes: List = ()):
        self.target_type = target_type
        self.regexes = REGEXES.get(target_column, []) + list(regexes)
        self.values = VALUES_CONVERSIONS.get(target_column, {})
        super().__init__(target_column)

    def _propose_conversions(self, column: Column, num_picks=2):
        # TODO: Do we want to use it at all?
        values = column.get_unique_values()

        if column.dtype in [ColumnType.STRING, ColumnType.MIXED]:
            target_vals = list(self.values.keys())
            candidates = [process_fuzzywuzzy(v, search_set=target_vals) for v in values]
            mapping_proposal = extract_proposals(values, candidates, num_picks)

            for k in mapping_proposal.keys():
                for i in mapping_proposal.get(k, []):
                    i.update({'conversion': self.values.get(i['value'])})

        else:
            mapping_proposal = {v: {'value': v, 'score': 100, 'conversion': self._convert_value(v)} for v in values}

        return mapping_proposal

    def _convert_value(self, value):
        raise NotImplementedError
